---
title: Go 垃圾回收
created: 2025-12-16 16:12:57
published: 2025-12-16 16:12:57
---
<!-- markdownlint-disable MD025 -->

# Go 垃圾回收

## 垃圾回收

垃圾回收（GC）在计算机科学中解决的核心问题只有一个：对象生命周期的自动化管理。

如果手动管理内存（如 C/C++ 的 `malloc/free`），我们面临的是由于”人为疏忽”导致的两个极端错误：

- **悬挂指针（Dangling Pointer）**：过早释放，导致后续访问出错。
- **内存泄漏（Memory Leak）**：忘记释放，导致资源耗尽。

GC 的出现，是为了将”判断内存是否不再使用”这个逻辑，从**业务代码**剥离，下沉到**运行时（Runtime）**。

从大的方面来讲，实现垃圾回收主要是要解决 2 个问题：

1. 怎么判断哪些对象是垃圾？
2. 如何清理垃圾？

### 垃圾搜索算法

从原理上讲，一个对象被判定为垃圾，意味着**当前程序的后续执行中，再也无法访问到它了**。这在计算机科学中被称为对象存活性（Object Liveness）问题。

主要有 2 个思路：引用计数法和可达性分析。

#### 引用计数法

- 给每个对象贴一个计数器。只要有一个地方引用它，计数器就 +1；引用失效（比如指针置空或离开作用域），计数器就 -1。当计数器归零时，该对象即为垃圾。一旦变成垃圾，立刻就能被回收，不需要等待特定的 GC 时间点。
- 但是存在**循环引用**的缺陷：假如对象 A 引用 B，B 也引用 A，除此之外没有其他人引用它们。虽然它们在外部已经无法访问（本质是垃圾），但它们互相揪着对方，计数器永远是 1，导致内存泄漏。
- CPython（Python 的解释器）的主力 GC 机制就是引用计数，但它配合了”标记-清除”来专门处理循环引用问题。PHP 和 C++ 的 `std::shared_ptr` 也是基于此思路。

#### 可达性分析

### 垃圾回收算法

## 宏观设计

在对 GC 有了一个简单的了解之后，我们先来详细了解 Go 语言的垃圾回收机制的宏观详细设计，在下一章节我们将在 AI 的帮助下，深入源码（Go1.25.3）去了解去背后的底层实现细节和那些令人叹为观止的优化思路。

截止 Go1.25，Go 还是使用的**三色标记法 + 并发标记清理法 + 混合写屏障**进行垃圾回收，Go 官方透露在 Go1.26 将默认开启 Green Tea GC，关于 Green Tea GC，将会在下篇进行详细展开

### 核心架构特征

- **并发标记-清扫**（Concurrent Mark-Sweep）
- **类型精确**（Type Accurate）：知道内存中哪些是指针
- **写屏障**（Write Barrier）：保证并发标记的正确性
- **非分代** (Non-generational)
- **非压缩**（Non-compacting）
- **Per-P 分配**：减少锁竞争

### 三色标记法

#### 基本原理

Go 将对象用三种颜色来进行标记：

- **黑色**：本对象已经被 GC 访问过，且本对象的子引用对象也已经被访问过了
- **灰色**：本对象已访问过，但是本对象的子引用对象还没有被访问过，全部访问完会变成黑色，属于中间态
- **白色**：尚未被GC访问过的对象，如果全部标记已完成依旧为白色的，称为不可达对象，既垃圾对象

#### 基本步骤

1. 起初所有堆上的对象都是【白色】的；
2. 将 GC Roots 直接引用到的对象挪到【灰色】中；
3. 对【灰色】的对象进行根搜索算法：
   1. 将该对象引用到的其他对象加入【灰色】中；
   2. 将自己挪到【黑色】中；
4. 重复 3 直到【灰色】为空；
5. 回收【白色】中的对象。

## Refer

- [- Zhihu](https://www.zhihu.com/question/21615032/answer/1982786809210610410)
- [-](https://draven.co/golang/docs/part3-runtime/ch07-memory/golang-garbage-collector/#%E4%B8%89%E8%89%B2%E6%8A%BD%E8%B1%A1)
