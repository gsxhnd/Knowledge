---
title: 内存分页
created: 2025-10-20 16:12
---
<!-- markdownlint-disable MD025 -->

# 内存分页

本文主要讲解 *内存分页* 机制，一种我们将会应用到操作系统里的十分常见的内存模型。同时，也会展开说明为何需要进行内存隔离、 *分段机制* 是如何运作的、 *虚拟内存* 是什么，以及内存分页是如何解决内存碎片问题的，同时也会对x86_64的多级页表布局进行探索。

## 内存保护

操作系统的主要任务之一就是隔离各个应用程序的执行环境，比如你的浏览器不应对你的文本编辑器造成影响，因此，操作系统会利用硬件级别的功能确保一个进程无法访问另一个进程的内存区域，但具体实现方式因硬件和操作系统实现而异。

比如一些 ARM Cortex-M 处理器（用于嵌入式系统）搭载了 [*内存保护单元*](https://developer.arm.com/docs/ddi0337/e/memory-protection-unit/about-the-mpu) (MPU)，该单元允许你定义少量具有不同读写权限的内存区域。MPU可以确保每一次对内存的访问都需要具备对应的权限，否则就会抛出异常。而操作系统则会在进程切换时，确保当前进程仅能访问自己所持有的内存区域，由此实现内存隔离。

在x86架构下，硬件层次为内存保护提供了两种不同的途径： [段](https://en.wikipedia.org/wiki/X86_memory_segmentation) 和 [页](https://en.wikipedia.org/wiki/Virtual_memory#Paged_virtual_memory) 。

## 内存分段

内存分段技术出现于1978年，初衷是用于扩展可用内存，该技术的最初背景是当时的CPU仅使用16位地址，而可使用的内存也只有64KiB。为了扩展可用内存，用于存储偏移量的段寄存器这个概念应运而生，CPU可以据此访问更多的内存，因此可用内存被成功扩展到了1MiB。

CPU可根据内存访问方式自动确定段寄存器的定义：对于指令获取操作，使用代码段寄存器 `CS` ；对于栈操作（入栈/出栈），使用栈段寄存器 `SS` ；对于其他指令，则使用数据段寄存器 `DS` 或额外段寄存器 `ES` 。另外还有两个后来添加的扩展段寄存器 `FS` 和 `GS` ，可以随意使用。

在最初版本的内存分段中，段寄存器仅仅是直接包含了偏移量，并不包含任何权限控制，直到 [*保护模式*](https://en.wikipedia.org/wiki/X86_memory_segmentation#Protected_mode) 这个概念的出现。当CPU进入此模式后，段描述符会包含一个本地或全局的 [*描述符表*](https://en.wikipedia.org/wiki/Global_Descriptor_Table) 索引，它对应的数据包含了偏移量、段的大小和访问权限。通过加载各个进程所属的全局/本地描述符表，可以实现进程仅能访问属于自己的内存区域的效果，操作系统也由此实现了进程隔离。

针对在判断权限前如何更正内存地址这个问题，内存分段使用了一个如今已经高度普及的技术： *虚拟内存* 。

### 虚拟内存

所谓虚拟内存，就是将物理存储器地址抽象为一段完全独立的内存区域，在直接访问物理存储器之前，加入了一个地址转换的步骤。对于内存分页机制而言，地址转换就是在虚拟地址的基础上加入偏移量，如在偏移量为 `0x1111000` 的段中，虚拟地址 `0x1234000` 的对应的物理内存地址是 `0x2345000` 。

首先我们需要明确两个名词，执行地址转换步骤之前的地址叫做 *虚拟地址* ，而转换后的地址叫做 *物理地址* ，两者最显著的区别就是物理地址是全局唯一的，而两个虚拟地址理论上可能指向同一个物理地址。同样的，如果使用不同的地址偏移量，同一个虚拟地址可能会对应不同的物理地址。
最直观的例子就是同时执行两个相同的程序：

![Two virtual address spaces with address 0–150, one translated to 100–250, the other to 300–450](https://os.phil-opp.com/zh-CN/paging-introduction/segmentation-same-program-twice.svg)

## Refer

- [内存分页初探](https://os.phil-opp.com/zh-CN/paging-introduction/)
